using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace ClubDarkAPI
{
	// Token: 0x02000015 RID: 21
	public class ExploitAPI
	{
		// Token: 0x06000072 RID: 114 RVA: 0x00006DB8 File Offset: 0x00004FB8
		private string ReadURL(string url)
		{
			return this.client.DownloadString(url);
		}

		// Token: 0x06000073 RID: 115 RVA: 0x00006DC8 File Offset: 0x00004FC8
		public void GoToUrl(string url)
		{
			Process.Start(url);
		}

		// Token: 0x06000074 RID: 116
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool WaitNamedPipe(string name, int timeout);

		// Token: 0x06000075 RID: 117 RVA: 0x00006DD4 File Offset: 0x00004FD4
		public static bool NamedPipeExist(string pipeName)
		{
			bool result;
			try
			{
				int timeout = 0;
				if (!ExploitAPI.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\\\\\.\\\\pipe\\\\{0}", pipeName)), timeout))
				{
					result = false;
				}
				else
				{
					result = true;
				}
			}
			catch (Exception)
			{
				result = false;
			}
			return result;
		}

		// Token: 0x06000076 RID: 118 RVA: 0x00006E28 File Offset: 0x00005028
		private void SMTP(string pipe, string input)
		{
			if (ExploitAPI.NamedPipeExist(pipe))
			{
				try
				{
					using (NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", pipe, PipeDirection.Out))
					{
						namedPipeClientStream.Connect();
						using (StreamWriter streamWriter = new StreamWriter(namedPipeClientStream))
						{
							streamWriter.Write(input);
							streamWriter.Dispose();
						}
						namedPipeClientStream.Dispose();
					}
					return;
				}
				catch (IOException)
				{
					MessageBox.Show("Error occured sending message to the game!", "Connection Failed!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					return;
				}
				catch (Exception ex)
				{
					MessageBox.Show(ex.Message.ToString());
					return;
				}
			}
			MessageBox.Show("Error occured. Did the dll properly inject?", "Oops", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
		}

		// Token: 0x06000077 RID: 119 RVA: 0x00006F0C File Offset: 0x0000510C
		public bool DownloadLatestVersion()
		{
			if (ExploitAPI.NamedPipeExist(Class3.luapipename))
			{
				MessageBox.Show("Kill Roblox To Proceed", "You injected clubdark.dll!");
				return false;
			}
			string text = this.ReadURL("https://clubdark.net/auto");
			if (File.Exists(ExploitAPI.exploitdllname))
			{
				File.Delete(ExploitAPI.exploitdllname);
			}
			this.client.DownloadFile(text.Split(new char[]
			{
				' '
			})[1], ExploitAPI.exploitdllname);
			return File.Exists(ExploitAPI.exploitdllname);
		}

		// Token: 0x06000078 RID: 120 RVA: 0x00006F94 File Offset: 0x00005194
		public void LaunchExploit()
		{
			if (ExploitAPI.NamedPipeExist(Class3.luapipename))
			{
				MessageBox.Show("Dll is already injected", "Stop injecting!");
				return;
			}
			if (!File.Exists(ExploitAPI.exploitdllname))
			{
				this.DownloadLatestVersion();
				return;
			}
			this.injector.InjectDLL();
		}

		// Token: 0x06000079 RID: 121 RVA: 0x00006FE8 File Offset: 0x000051E8
		public void ExecuteScript(string script)
		{
			if (ExploitAPI.NamedPipeExist(Class3.luapipename))
			{
				Class3.LuaPipe(script);
				return;
			}
			MessageBox.Show("Inject " + ExploitAPI.exploitdllname + " before using this", "OOF!");
		}

		// Token: 0x0600007A RID: 122 RVA: 0x00007020 File Offset: 0x00005220
		public void ExecuteLink(string url)
		{
			if (ExploitAPI.NamedPipeExist(Class3.luapipename))
			{
				Class3.RUNURL(url);
				return;
			}
			MessageBox.Show("Inject " + ExploitAPI.exploitdllname + " before using this", "OOF!");
		}

		// Token: 0x0600007B RID: 123 RVA: 0x00007058 File Offset: 0x00005258
		public void KillRoblox()
		{
			foreach (Process process in Process.GetProcesses())
			{
				if (process.ProcessName == "RobloxPlayerBeta")
				{
					process.Kill();
				}
			}
		}

		// Token: 0x04000068 RID: 104
		public static string exploitdllname = "clubdark.dll";

		// Token: 0x04000069 RID: 105
		private WebClient client = new WebClient();

		// Token: 0x0400006A RID: 106
		private ExploitAPI.BasicInject injector = new ExploitAPI.BasicInject();

		// Token: 0x02000022 RID: 34
		private class BasicInject
		{
			// Token: 0x060000EF RID: 239
			[DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
			internal static extern IntPtr LoadLibraryA(string lpFileName);

			// Token: 0x060000F0 RID: 240
			[DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
			internal static extern UIntPtr GetProcAddress(IntPtr hModule, string procName);

			// Token: 0x060000F1 RID: 241
			[DllImport("kernel32.dll", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			internal static extern bool FreeLibrary(IntPtr hModule);

			// Token: 0x060000F2 RID: 242
			[DllImport("kernel32.dll")]
			internal static extern IntPtr OpenProcess(ExploitAPI.BasicInject.ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);

			// Token: 0x060000F3 RID: 243
			[DllImport("kernel32.dll", SetLastError = true)]
			internal static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

			// Token: 0x060000F4 RID: 244
			[DllImport("kernel32.dll", SetLastError = true)]
			internal static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

			// Token: 0x060000F5 RID: 245
			[DllImport("kernel32.dll")]
			internal static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, UIntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

			// Token: 0x060000F6 RID: 246
			[DllImport("kernel32.dll", SetLastError = true)]
			internal static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);

			// Token: 0x060000F7 RID: 247
			[DllImport("key.dll")]
			private static extern void keySaving();

			// Token: 0x060000F8 RID: 248
			[DllImport("key.dll")]
			private static extern bool checkDone();

			// Token: 0x060000F9 RID: 249 RVA: 0x00008860 File Offset: 0x00006A60
			private string ReadURL(string url)
			{
				return this.client.DownloadString(url);
			}

			// Token: 0x060000FA RID: 250 RVA: 0x00008870 File Offset: 0x00006A70
			public bool InjectDLL()
			{
				if (Process.GetProcessesByName("RobloxPlayerBeta").Length == 0)
				{
					return false;
				}
				Process process = Process.GetProcessesByName("RobloxPlayerBeta")[0];
				byte[] bytes = new ASCIIEncoding().GetBytes(AppDomain.CurrentDomain.BaseDirectory + ExploitAPI.exploitdllname);
				IntPtr hModule = ExploitAPI.BasicInject.LoadLibraryA("kernel32.dll");
				UIntPtr procAddress = ExploitAPI.BasicInject.GetProcAddress(hModule, "LoadLibraryA");
				ExploitAPI.BasicInject.FreeLibrary(hModule);
				if (procAddress == UIntPtr.Zero)
				{
					return false;
				}
				IntPtr intPtr = ExploitAPI.BasicInject.OpenProcess(ExploitAPI.BasicInject.ProcessAccess.AllAccess, false, process.Id);
				if (intPtr == IntPtr.Zero)
				{
					return false;
				}
				IntPtr intPtr2 = ExploitAPI.BasicInject.VirtualAllocEx(intPtr, (IntPtr)0, (uint)bytes.Length, 12288U, 4U);
				UIntPtr uintPtr;
				IntPtr intPtr3;
				return !(intPtr2 == IntPtr.Zero) && ExploitAPI.BasicInject.WriteProcessMemory(intPtr, intPtr2, bytes, (uint)bytes.Length, out uintPtr) && !(ExploitAPI.BasicInject.CreateRemoteThread(intPtr, (IntPtr)0, 0U, procAddress, intPtr2, 0U, out intPtr3) == IntPtr.Zero);
			}

			// Token: 0x0400009F RID: 159
			private WebClient client = new WebClient();

			// Token: 0x02000027 RID: 39
			[Flags]
			public enum ProcessAccess
			{
				// Token: 0x040000AC RID: 172
				AllAccess = 1050235,
				// Token: 0x040000AD RID: 173
				CreateThread = 2,
				// Token: 0x040000AE RID: 174
				DuplicateHandle = 64,
				// Token: 0x040000AF RID: 175
				QueryInformation = 1024,
				// Token: 0x040000B0 RID: 176
				SetInformation = 512,
				// Token: 0x040000B1 RID: 177
				Terminate = 1,
				// Token: 0x040000B2 RID: 178
				VMOperation = 8,
				// Token: 0x040000B3 RID: 179
				VMRead = 16,
				// Token: 0x040000B4 RID: 180
				VMWrite = 32,
				// Token: 0x040000B5 RID: 181
				Synchronize = 1048576
			}
		}
	}
}
